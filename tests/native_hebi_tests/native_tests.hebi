"""
Native tests in the Hebi-go.
"""

from: unittest :import TestCase

from: hypothesis :import given
from: hypothesis :import strategies :as st
# TODO: why isn't the below version working?
# import: hypothesis.strategies :as st

from: hebi.bootstrap :import function

print: st

hissp.basic.._macro_.requirexH_as:
    hissp.basic.._macro_.deftype deftype

print: TestCase

def: greet: name
    print: "Hello," name

deftype: TestNative pass:TestCase
    test_mask lambda: self:
        self.assertEqual:
            quote:pass:lambda: pass: : foo spam
                builtins..print: "Hi!"
                tests.native_hebi_tests.native_tests..greet: "World!"
                frobnicate: foo 7 24
                reticulate: foo spline
                foo
            pass:  # Example based on cascade macro.
                lambda: pass: thing thing_sym : :* calls
                    !mask:pass:lambda: pass: : :,:thing_sym :,:thing
                        print: "Hi!"  # Builtin symbol.
                        greet: "World!"  # Local symbol.
                        :,@:map:  # Splice
                            lambda: pass:call
                                !mask:pass:  # Nested !mask.
                                    :,:operator..getitem: call 0
                                    :,:thing_sym
                                    :,@:operator..getitem: call slice: 1 None
                            calls
                        :,:thing_sym
                : :*
                quote:pass: spam foo
                    frobnicate: 7 24
                    reticulate: spline
    test_elif lambda: self:
        self.assertEqual:
            quote:hebi.bootstrap.._if_:
                ('a'<'b')
                lambda: pass:
                    print: "less"
                lambda: pass:
                    ('a'>'b')
                lambda: pass:
                    print: "more"
                lambda: pass:
                    ('a'=='b')
                lambda: pass:
                    print: "equal"
                : else_
                lambda: pass:
                    print: "nan"
            hebi.bootstrap..if_:
                : :* quote:pass:
                    ('a'<'b')
                    :then:
                        print: "less"
                    :elif: ('a'>'b')
                        print: "more"
                    :elif: ('a'=='b')
                        print: "equal"
                    :else:
                        print: "nan"

deftype: TestAnd pass:TestCase
    test_null lambda: self:
        self.assertIs:
            True
            and:
    test_one pass:
        given: st.from_type: type
        function: quote:test_one
            lambda: self: x
                self.assertIs:
                    x
                    and: x
    test_two pass:
        given:
            st.from_type: type
            st.from_type: type
        function: quote:test_two
            lambda: self: x y
                self.assertIs:
                    (x and y)
                    and: x y
    test_shortcut lambda: self:
        and: 0 (0/0)
        and: 1 0 (0/0)
        and: 0 (0/0) (0/0)
    test_three pass:
        given:
            st.from_type: type
            st.from_type: type
            st.from_type: type
        function: quote:test_three
            lambda: self: x y z
                self.assertIs:
                    (x and y and z)
                    and: x y z

deftype: TestOr pass:TestCase
    test_null lambda: self:
        self.assertEqual:
            ()
            or:
    test_one pass:
        given: st.from_type: type
        function: quote:test_one
            lambda: self: x
                self.assertIs:
                    x
                    or: x
    test_two pass:
        given:
            st.from_type: type
            st.from_type: type
        function: quote:test_two
            lambda: self: x y
                self.assertIs:
                    (x or y)
                    or: x y
    test_shortcut lambda: self:
        or: 1 (0/0)
        or: 0 1 (0/0)
        or: 1 (0/0) (0/0)
    test_three pass:
        given:
            st.from_type: type
            st.from_type: type
            st.from_type: type
        function: quote:test_three
            lambda: self: x y z
                self.assertIs:
                    (x or y or z)
                    or: x y z

deftype: TestLet pass:TestCase
    test_single lambda: self:
        self.assertEqual:
            42
            !let: a :be (40 + 2)
                a
    test_2 lambda: self:
        self.assertEqual:
            24
            !let:
                :,: a b
                :be [20, 4]
                (a + b)
    test_nested lambda: self:
        self.assertEqual:
            [-5, -50]
            !let:
                :,: :,: x1 y1
                    :,: x2 y2
                :be [[1, 10],
                       [6, 60]]
                [x1 - x2, y1 - y2]
    test_ignored lambda: self:
        self.assertEqual:
            [1, 4, 5]
            !let:
                :,: a _ _ d e
                :be [1, 2, 3, 4, 5]
                [a, d, e]
    test_list lambda: self:
        self.assertEqual:
            [1, 2, [3, 4, 5]]
            !let:
                :,: a b :list c
                :be [1, 2, 3, 4, 5]
                [a, b, c]
    test_iter lambda: self:
        self.assertEqual:
            ['a', 'c', 'b', 'd', 'e']
            !let:
                :,: a b :iter c
                :be 'abcde'
                [a, next(c), b, *c]
    test_mapping lambda: self:
        self.assertEqual:
            ['one', 'bar']
            !let: :=: a 1  b 'foo'
                :be {1: 'one', 'foo': 'bar'}
                [a, b]
    test_nested_mapping lambda: self:
        self.assertEqual:
            ['one', 'spam', 'eggs']
            !let:
                :=: a 1
                    :=: b 'foo'
                    2
                    :=: c 'bar'
                    3
                :be {1: 'one',
                       2: {'foo': 'spam'},
                       3: {'bar': 'eggs'}}
                [a, b, c]
    test_too_many lambda: self:
        self.assertEqual:
            [1, 2, 3]
            !let:
                :,: a b c
                :be [1, 2, 3, 4, 5]
                [a, b, c]
    test_as lambda: self:
        self.assertEqual:
            [[3,7], 3, 7, 'xy', 'x', 'y']
            !let:
                :,: :,: x1 y1 :as point1
                    :,: x2 y2 :as point2
                :be [[3, 7], 'xy']
                [point1, x1, y1, point2, x2, y2]
    test_mapping_as lambda: self:
        self.assertEqual:
            ['spam', {1:'spam'}]
            !let: :=: s 1 :as d
                :be {1:'spam'}
                [s, d]
    test_nested_mixed lambda: self:
        self.assertEqual:
            ['a', 'b', 'ab']
            !let:
                :=: :,: a b :as s
                    1
                :be {1:'ab'}
                [a, b, s]
        self.assertEqual:
            [[{1:'ab'}], 'ab']
            !let:
                :,: :=: s 1
                    :as d
                :be [{1:'ab'}]
                [d, s]
        self.assertEqual:
            ['a', 'b', [{1:'ab'}], 'ab']
            !let:
                :,:
                    :=: :,: a b :as s
                        1
                    :as d
                :be [{1:'ab'}]
                [a, b, d, s]
        self.assertEqual:
            'spam'
            !let:
                :=: :,: :=: s 2
                    1
                :be {1:[{2:'spam'}]}
                s
    test_strs lambda: self:
        self.assertEqual:
            [1, 2, 3]
            !let: :=: :strs: a b c
                :be {'a':1, 'b':2, 'c':3}
                [a, b, c]
    test_default lambda: self:
        self.assertEqual:
            ['A','b','C','d']
            !let: :=: a 1  b 2  c 3  d 4  :default: a 'A'  b 'X'  c 'C'
                :be {2:'b', 4:'d'}
                [a,b,c,d]
    test_default_strs lambda: self:
        self.assertEqual:
            ['ab', 22, 33]
            !let:
                :=: :strs: a b c
                    :default: a ('a'+'b')
                :be {'b':22,'c':33}
                [a, b, c]

deftype: TestLoop pass:TestCase
    test_loop lambda: self:
        self.assertEqual:
            'cba'
            !loop: recur: xs 'abc'  ys ''
                if: xs
                    :then: (recur(xs[:-1], ys + xs[-1]))
                    :else: ys
    test_try_iter lambda: self:
        !let: xs :be []
            !loop: recur: it iter:'abc'
                try: .append: xs .upper:next:it
                    :except: StopIteration
                    :else: recur:it
            self.assertEqual:
                ['A', 'B', 'C']
                xs
    test_for lambda: self:
        !let: xs :be []
            for: c :in 'abc'
                .append: xs .upper:c
            self.assertEqual:
                ['A', 'B', 'C']
                xs
    test_for_bind lambda: self:
        !let: xs :be []
            for: :,: c i
                :in zip: 'abc' [1,2,3]
                xs.append:(c*i)
            self.assertEqual:
                ['a','bb','ccc']
                xs
    test_break lambda: self:
        !let: cs :be iter:'abcdefg'
            self.assertEqual:
                'c'
                for: c :in cs
                    if: (c=='c')
                        :then: break: c
            self.assertEqual:
                ['d', 'e', 'f', 'g']
                list:cs
        self.assertEqual:
            None
            for: c :in 'abc'
                if: (c=='c')
                    :then: break:
    test_labeled_break lambda: self:
        !let: ijs :be []
            self.assertEqual:
                1
                for: :top i :in [0,1,2,3]
                    for: j :in [2,1]
                        ijs.append: [i, j]
                        if: (i==j) :then: break: :top i
            self.assertEqual:
                [[0, 2],
                 [0, 1],
                 [1, 2],
                 [1, 1]]
                ijs
    test_continue lambda: self:
        !let: ijs :be []
            self.assertEqual:
                ()
                for: i :in [1,2,3]
                    for: j :in [1,2,3]
                        if: (i==j) :then: continue:
                        ijs.append: [i, j]
            self.assertEqual:
                [[1, 2],
                 [1, 3],
                 [2, 1],
                 [2, 3],
                 [3, 1],
                 [3, 2]]
                ijs
    test_labeled_continue lambda: self:
        !let: ijs :be []
            self.assertEqual:
                ()
                for: :top i :in [1,2,3]
                    for: j :in [1,2,3]
                        if: (i==j) :then: continue: :top
                        ijs.append: [i, j]
            self.assertEqual:
                [[2, 1],
                 [3, 1],
                 [3, 2]]
                ijs


# TODO: test for/do/else, !begin, try


# !let: :.: :syms: a b
#     !let: ns types..SimpleNamespace:
#         !attach: ns : a 20  b 4
#         (ns.a + ns.b)
# class: type ns
#     a 20
#     b (ns.a + ns.a)
#     type:
# TODO: implement class:
# class: TestNative: TestCase
#     def: test_fail: self
#         self.fail:

#def: __package__ "tests.native_hebi_tests"

import: unittest

if: (__name__ == "__main__")
    :then:
        # print: __package__
        # from: . :import recompile
        .main: unittest
        # recompile:
